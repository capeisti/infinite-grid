<!-- Dependency resources -->
<link rel="import" href="../bower_components/polymer/polymer-element.html">

<dom-module id="infinite-grid">
    <template>
        <style include="shared-styles">
            :host {
                display: inline-block;
                padding: 0;
                margin: 0;
                position: relative;
            }

            .scrollarea {
                position: absolute;
                top: 0;
                bottom: 0;
                left: 0;
                right: 0;
                padding: 0;
                margin: 0;
                overflow: auto;
            }

            #headerscrollarea {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                overflow: hidden;
                z-index: 100;
            }
            .container {
                padding: 0;
                margin: 0;
                overflow: hidden;
                position: relative;
            }

            .storage {
                display: none;
            }

            .row {
                display: block;
                white-space: nowrap;
                position: absolute;
            }

            .cell {
                overflow: hidden;
                display: inline-block;
                box-sizing: border-box;
                position: absolute;
            }

            .frozen > .cell {
                background-color: #f7f7f7;
                z-index: 50;
            }

            .cell.frozen {
                background-color: #f7f7f7;
                z-index: 5;
            }

            .frozen > .cell.frozen {
                z-index: 10;
             }

            .row.frozen > .cell.frozen {
                z-index: 100;
            }




        </style>

        <div id="headerscrollarea">
            <div id="headers" class="container"></div>
        </div>

        <div id="scrollarea" class="scrollarea">
            <div id="container" class="container"></div>
        </div>

        <div id="storage" class="storage"></div>
    </template>

    <script>
        class InfiniteGrid extends Polymer.Element {
            static get is() {
                return 'infinite-grid'
            }

            ready() {
                super.ready();
                var that = this;
                this.$.scrollarea.addEventListener('scroll', pos => that.ensureFrozen(), {passive: true});
                this.$.scrollarea.addEventListener('scroll', pos => that.onScroll(), {passive: true});
            }

            static get properties() {
                return {
                    dimensions: {type: Object, observer: 'dimensionsChanged'},
                    textOnly: {type: Boolean},
                    useDomBind: {type: Boolean}
                }
            }

            dimensionsChanged(dimensions) {
                var that = this;
                this.cellWidth = dimensions.cellWidth;
                this.cellHeight = dimensions.cellHeight;
                this.frozenRows = dimensions.frozenRows;
                this.frozenColumns = dimensions.frozenColumns;

                this.$.container.style.width = dimensions.cellCountX*this.cellWidth+"px";
                this.$.container.style.height = dimensions.cellCountY*this.cellHeight+"px";
                this.$.container.style.marginTop = "-"+(this.frozenRows*this.cellHeight)+"px";

                this.$.headers.style.width = dimensions.cellCountX*this.cellWidth+"px";
                this.$.headers.style.height = this.frozenRows*this.cellHeight+"px";
                this.$.scrollarea.style.marginTop = this.$.headers.style.height;

                setTimeout(() => that.createGrid(), 100);
            }

            createTemplate(content) {
                var dbind = document.createElement('dom-bind');
                var template = document.createElement('template');
                dbind.appendChild(template);
                template.innerHTML = content;
                return dbind;
            }

            setContent(json) {
                let that = this;
                JSON.parse(json).forEach(celldata => {
                    setTimeout(() => {
                        let cell = this.$.container.querySelector("#cid"+celldata.x+"_"+celldata.y);
                        if (cell === null) {
                            cell = this.$.headers.querySelector("#cid"+celldata.x+"_"+celldata.y);
                        }

                        if (cell != null) {
                            if (celldata.m != null) {
                                if (this.useDomBind == true) {
                                    var template = this.createTemplate(celldata.m);
                                    template.x = celldata.x;
                                    template.y = celldata.y;
                                    this.clearChildren(cell);
                                    cell.appendChild(template);
                                } else if(this.textOnly == true) {
                                    cell.innerText = celldata.m;
                                } else {
                                    cell.innerHTML = celldata.m;
                                }
                            } else {
                                let c = this.$.storage.querySelector("#id"+celldata.x+"_"+celldata.y);
                                if (c != null) {
                                    this.clearChildren(cell);
                                    cell.appendChild(c);
                                } else {
                                    console.info("cannot find "+celldata.x+"_"+celldata.y);
                                }
                            }
                        } else {
                            console.info("no cid"+celldata.x+"_"+celldata.y)
                        }
                    }, 1);
                });
            }

            createGrid() {
                this.prePosX = 0;
                this.prePosY = 0;
                let ask = [];
                let maxY = Math.ceil(this.$.scrollarea.offsetHeight/this.cellHeight)+this.bufferY;
                let maxX = Math.ceil(this.$.scrollarea.offsetWidth/this.cellWidth)+this.bufferX;
                //Clear possible old nodes
                this.clearChildren(this.$.container);

                for (var y = 0; y < maxY; y++) {
                    let row = document.createElement("div");
                    row.id = "rid"+y;
                    row.y = y;
                    row.classList.add("row");
                    row.style.top = (y*this.cellHeight)+"px";

                    if (y < this.frozenRows) {
                        row.classList.add("frozen");
                        this.$.headers.appendChild(row);
                    } else {
                        this.$.container.appendChild(row);
                    }

                    for (var x = 0; x < maxX; x++) {
                        let span = document.createElement('span');
                        let coord = x+"_"+row.y;
                        span.id = "cid"+coord;
                        span.x = x;
                        span.y = row.y;
                        ask.push(coord);
                        span.classList.add('cell');

                        if (x < this.frozenColumns) {
                            span.classList.add("frozen");
                        }

                        span.style.width = this.cellWidth+"px";
                        span.style.height = this.cellHeight+"px";
                        row.appendChild(span);
                        span.style.left = (x*this.cellWidth)+"px";

                        if(this.domTemplate != null) {
                            var template = this.createTemplate(this.domTemplate);
                            template.x = span.x;
                            template.y = span.y;
                            span.appendChild(template);
                        }
                    }
                }

                if (this.domTemplate == null) {
                    this.$server.getContent(ask);
                }
            }

            ensureNoFrozenX(x) {
                return x + this.frozenColumns;
            }

            drawGrid(container, initialX, initialY) {
                let ask = [];

                let y = initialY;
                for(let i = 0; i < container.childNodes.length; i++) {
                    let row = container.childNodes[i];
                    row.id = "rid" + y;
                    row.y = y;
                    row.style.top = (y * this.cellHeight) + "px";
                    y++;

                    let x = this.ensureNoFrozenX(initialX);
                    for (let j = 0; j < row.childNodes.length; j++) {
                        let cell = row.childNodes[j];

                        if(!cell.classList.contains("frozen")) {
                            cell.id = "cid" + x + "_" + row.y;
                            cell.x = x;
                            cell.y = row.y;
                            cell.style.left = (cell.x * this.cellWidth) + "px";
                            x++;
                        } else {
                            cell.id = "cid"+ cell.x+"_"+row.y;
                            cell.y = row.y;
                        }

                        this.prepareAskContent(cell, ask);
                    }
                }

                if (this.domTemplate == null) {
                    this.$server.getContent(ask);
                }
            }

            clearChildren(node) {
                while(node.firstChild) {
                    node.removeChild(node.firstChild);
                }
            }

            prepareAskContent(col, ask) {
                if (col.x < 0 ||
                    col.parentNode.y < 0 ||
                    col.x >= this.dimensions.cellCountX ||
                    col.parentNode.y >= this.dimensions.cellCountY) {
                    return;
                }

                if (this.domTemplate == null) {
                    col.childNodes.forEach(child => col.removeChild(child));
                    ask.push(col.x+"_"+col.parentNode.y);
                } else {
                    col.childNodes.forEach(child => {
                        child.x = col.x;
                        child.y = col.parentNode.y;
                    });
                }
            }

            isRedrawingMoreEfficient(changeX, changeY) {
                return Math.abs(changeY) > (Math.ceil(this.$.scrollarea.offsetHeight/this.cellHeight)+this.bufferY)/2 ||
                    Math.abs(changeX) > (Math.ceil(this.$.scrollarea.offsetWidth/this.cellWidth)+this.bufferX)/2;
            }

            ensureFrozen() {
                this.$.headerscrollarea.scrollLeft = this.$.scrollarea.scrollLeft;
                this.ensureFrozenColumns(this.$.container);
                this.ensureFrozenColumns(this.$.headers);
            }

            ensureFrozenColumns(container) {
                container.childNodes.forEach(row => {
                    for (var i = 0; i < this.frozenColumns; i++) {
                        var cell = row.childNodes[i];
                        cell.style.left = (container.parentNode.scrollLeft + i*this.cellWidth)+"px";
                    }
                });
            }

            getFirst(container) {
                for(var i = 0; i < container.childNodes.length; i++) {
                    if (!container.childNodes[i].classList.contains("frozen")) {
                        return container.childNodes[i];
                    }
                }

                return null;
            }

            getLast(container) {
                for(var i = container.childNodes.length-1; i >= 0; i--) {
                    if (!container.childNodes[i].classList.contains("frozen")) {
                        return container.childNodes[i];
                    }
                }

                return null;
            }

            onScrollYDown(container, ask) {
                let first = container.firstChild;
                let last = container.lastChild;
                container.removeChild(first);
                container.appendChild(first);
                let y = last.y+1;
                if (y >=0 && y < this.frozenRows) {
                    y += this.frozenRows;
                }
                this.onScrollY(first, y, ask);
            }

            onScrollYUp(container, ask) {
                let last = container.lastChild;
                let first = container.firstChild;
                container.removeChild(last);
                container.insertBefore(last, first);
                let y = first.y-1;
                if (y >=0 && y < this.frozenRows) {
                    y -= this.frozenRows;
                }
                this.onScrollY(last, y, ask);
            }

            onScrollY(row, y, ask) {
                row.style.top = (y*this.cellHeight) + "px";
                row.y = y;
                row.id = "rid"+y;
                row.childNodes.forEach(col => {
                    let x = Math.floor(col.offsetLeft/this.cellWidth);
                    col.id = "cid"+col.x+"_"+y;
                    this.prepareAskContent(col, ask);
                });
            }

            onScrollXDown(container, ask) {
                container.childNodes.forEach(row => {
                    let first = this.getFirst(row);
                    let last = this.getLast(row);
                    row.removeChild(first);
                    row.appendChild(first);

                    let x = last.x+1;
                    if (x >= 0 && x < this.frozenColumns) {
                        x += this.frozenColumns;
                    }

                    first.style.left = (x*this.cellWidth) + "px";
                    first.x = x;
                    first.id = "cid"+x+"_"+first.parentNode.y;
                    this.prepareAskContent(first, ask);
                });
            }

            onScrollXUp(container, ask) {
                container.childNodes.forEach(row => {
                    let first = this.getFirst(row);
                    let last = this.getLast(row);
                    row.removeChild(last);
                    row.insertBefore(last, first);

                    let x = first.x-1;
                    if (x >= 0 && x < this.frozenColumns) {
                        x -= this.frozenColumns;
                    }

                    last.style.left = (x*this.cellWidth) + "px";
                    last.x = x;
                    last.id = "cid"+x+"_"+last.parentNode.y;
                    this.prepareAskContent(last, ask);
                });

            }

            onScroll() {
                let currX = Math.floor(this.$.scrollarea.scrollLeft/this.cellWidth);
                let currY = Math.floor(this.$.scrollarea.scrollTop/this.cellHeight);
                let changeY = currY - this.prePosY;
                let changeX = currX - this.prePosX;
                this.prePosY = currY;
                this.prePosX = currX;
                var ask = [];
                if (this.isRedrawingMoreEfficient(changeX, changeY) === true) {
                    this.drawGrid(this.$.container, currX, currY+this.frozenRows);
                    this.drawGrid(this.$.headers, currX, 0);
                    return;
                }

                let bufferCutOff = 2;

                let bottom = currY + Math.ceil(this.$.scrollarea.offsetHeight/this.cellHeight);
                let topVisible = this.$.container.lastChild.y - this.$.container.childNodes.length;
                let reserveBottom = this.$.container.lastChild.y - bottom + 1;
                let reserveTop = currY - topVisible - 1;

                let right = currX + Math.ceil(this.$.scrollarea.offsetWidth/this.cellWidth);
                let leftVisible = this.$.container.lastChild.lastChild.x - this.$.container.lastChild.childNodes.length;
                let reserveRight = this.$.container.lastChild.lastChild.x - right;
                let reserveLeft = currX - leftVisible - 1;

                if (changeY > 0 && reserveBottom < this.bufferY/bufferCutOff) {
                    for (var i = 0; i <  Math.abs(reserveTop-1); i++) {
                        this.onScrollYDown(this.$.container, ask);
                    }
                } else if (changeY < 0 && reserveTop < this.bufferY/bufferCutOff) {
                    for (var i = 0; i <  Math.abs(reserveBottom-1); i++) {
                        this.onScrollYUp(this.$.container, ask);
                    }
                }

                if (changeX > 0 && reserveRight < this.bufferX/bufferCutOff) {
                    for (var i = 0; i <  Math.abs(reserveLeft-1); i++) {
                        this.onScrollXDown(this.$.container, ask);
                        this.onScrollXDown(this.$.headers, ask);
                    }
                } else if (changeX < 0 && reserveLeft < this.bufferX/bufferCutOff) {
                    for (var i = 0; i <  Math.abs(reserveRight-1); i++) {
                        this.onScrollXUp(this.$.container, ask);
                        this.onScrollXUp(this.$.headers, ask);
                    }
                }

                if (ask.length > 0) {
                    this.$server.getContent(ask);
                }
            }
        }
        customElements.define(InfiniteGrid.is, InfiniteGrid);
    </script>
</dom-module>